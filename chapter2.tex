\chapter{FOUNDATIONAL DESIGN PRINCIPLES OF THE SYSTEM}
\section{Keeping provenance of the data}
\subsection{Actions}

The definition of what an action is will dictate the possibility of designing practical functionality that will allow us to optimize the time spent computing a workflow.  In essence, that practical functionality refers to skipping certain computations of actions because we have previously computed the datasets that are the output of those computations. 

Simplifying things, we can think of an action as a pure function $f:A \rightarrow B$.  Suppose that we are asked to compute $f(a)$.  If we have previously computed $b=g(c)$, and we can determine that $g=f$ and that $c=a$, then we can skip the computation of $f(a)$ (if it is that we still have $b$ among us.  Determining if $a$ and $c$ are equal to each other is trivial, but it can be time consuming if the inputs are big.  Determining if $f$ and $g$ are equivalent is more difficult and has deep theoretical ramifications (it is computationally imposible in the most broad sense, since the Halting Problem can be reduced to this problem).

Also, comparing our actions to pure mathematical functions is not completely accurate.  \cite{wiki:pure_function} says that a pure function is a function that "always evaluates the same result value given the same argument values.  The function result cannot depend on any hidden information or state that may change while program execution proceeds." In some cases, as we will see in the next chapter, there will be nothing stopping our actions from reading values from environmental variables.

Because of these difficulties, we need to devise a more practical approach to determine the equality of two actions.  That approach needs to be derived from a closer look to the functionality that we want our ideal system to embody.  The system will receive descriptions of actions as structured text.  As Figure \ref{fig:hypothetical_inputs} shows, those descriptions are simply a collection of parameters such as: path to input folders, path to the executable of the action, extra input parameters, etc.

\begin{figure}

\begin{mdframed}
\begin{verbatim}

	{
	   input: ["/path/to/input1", "/path/to/input2"],
	   output: "/path/to/output",
	   executable: ["/path/to/executable"],
	   inputParameters: [ {key: "arg1", value: "Hello"}, 
	                                 {key: "arg2", value: "World!"}]
	} 

\end{verbatim}
\end{mdframed}

\caption{Hypothetical example of description of an action}
\label{fig:hypothetical_inputs}
\end{figure} 


\subsection{Workflows}
\section{Bounded storage space}
\subsection{The History of Workflows}
\section{A multi-user multi-component system}